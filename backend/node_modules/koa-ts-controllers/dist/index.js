"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
const generateRoutes_1 = require("./util/generateRoutes");
const importClasses_1 = require("./util/importClasses");
exports.metadata = {
    controllers: {}
};
function getControllers() {
    return exports.metadata.controllers;
}
exports.getControllers = getControllers;
const defaultErrorHandler = async (err, ctx) => {
    if (err.isBoom) {
        const error = err.output.payload;
        error.errorDetails = error.statusCode >= 500 ? undefined : err.data;
        ctx.body = error;
        ctx.status = error.statusCode;
        if (error.statusCode >= 500)
            console.error(err);
    }
    else {
        ctx.body = { error: "Internal Server Error" };
        ctx.status = 500;
        console.error(err);
    }
};
exports.controllers = {};
/**
 *
 * @param app - Koa instance
 * @param params - KoaControllerOptions
 */
exports.bootstrapControllers = async (app, params) => {
    exports.options = params;
    exports.options.versions = exports.options.versions || { 1: true };
    exports.options.flow = exports.options.flow || [];
    exports.options.errorHandler = exports.options.errorHandler || defaultErrorHandler;
    /**
     * Versions can be defined in multiple ways.
     * If an array, it's just a list of active versions.
     * If as an object, then this datastructure can define not only active versions but obsolete versions as well.
     *
     * The object is the native form. Arrays are converted to object.
     */
    if (Array.isArray(exports.options.versions)) {
        const versions = {};
        exports.options.versions.forEach(version => {
            versions[version] = true;
        });
        exports.options.versions = versions;
    }
    app.use(async (ctx, next) => {
        try {
            await next();
        }
        catch (err) {
            exports.options.errorHandler(err, ctx);
        }
    });
    // We don't need to do anything with the array of Controller classes these
    // return because the decorators have already loaded up the classes into metadata.
    // The Controller class files just need to be touched and they will handle their own registration in metadata
    for (const controllerDef of exports.options.controllers) {
        if (typeof controllerDef === "string") {
            importClasses_1.importClassesFromDirectories(controllerDef);
        }
        else {
            // if it is not a string, it means it is a class that has already been imported/required/loaded. No need to
            // do anything else. Encourage users to still add the controller classes here even though the
            // decorators already load things up, for possible future needs.
        }
    }
    await generateRoutes_1.generateRoutes(exports.options.router, exports.options, exports.metadata);
};
__export(require("class-validator"));
var decorators_1 = require("./decorators");
exports.Body = decorators_1.Body;
exports.Controller = decorators_1.Controller;
exports.Ctx = decorators_1.Ctx;
exports.Delete = decorators_1.Delete;
exports.Flow = decorators_1.Flow;
exports.Get = decorators_1.Get;
exports.Header = decorators_1.Header;
exports.Params = decorators_1.Params;
exports.Patch = decorators_1.Patch;
exports.Post = decorators_1.Post;
exports.Put = decorators_1.Put;
exports.Query = decorators_1.Query;
exports.Req = decorators_1.Req;
exports.Res = decorators_1.Res;
exports.Session = decorators_1.Session;
exports.State = decorators_1.State;
exports.Version = decorators_1.Version;
//# sourceMappingURL=index.js.map