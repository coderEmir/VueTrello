"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
require("reflect-metadata");
const index_1 = require("./index");
function Controller(baseRoute) {
    return function (classDefinition) {
        const controller = index_1.metadata.controllers[classDefinition.name] || {};
        controller.path = baseRoute;
        controller.class = classDefinition;
        index_1.metadata.controllers[classDefinition.name] = controller;
    };
}
exports.Controller = Controller;
// Function decorators
function _addVerbFunctionMeta({ verb, path, object, methodName }) {
    const controller = index_1.metadata.controllers[object.constructor.name] || {};
    controller.actions = controller.actions || {};
    controller.actions[methodName] = controller.actions[methodName] || {};
    const argumentTypes = Reflect.getMetadata("design:paramtypes", object, methodName);
    controller.actions[methodName].verb = verb;
    controller.actions[methodName].path = path;
    controller.actions[methodName].target = object[methodName];
    controller.actions[methodName].argumentTypes = argumentTypes;
    index_1.metadata.controllers[object.constructor.name] = controller;
}
function _addVersionFunctionMeta({ version, methodName, object, endpointDeprecationWarning }) {
    const controller = index_1.metadata.controllers[object.constructor.name] || {};
    controller.actions = controller.actions || {};
    controller.actions[methodName] = controller.actions[methodName] || {};
    // The presence of versions signifies that this method might be unavailable for some versions and should
    // be skipped in final metadata processing step
    controller.actions[methodName].limitToVersions =
        controller.actions[methodName].limitToVersions || {};
    controller.actions[methodName].limitToVersions[version] =
        endpointDeprecationWarning || true;
    index_1.metadata.controllers[object.constructor.name] = controller;
}
function _addFlowFunctionMeta({ flow, methodName, object }) {
    const flowArray = Array.isArray(flow) ? flow : [flow];
    const controller = index_1.metadata.controllers[object.constructor.name] || {};
    controller.actions = controller.actions || {};
    controller.actions[methodName] = controller.actions[methodName] || {};
    controller.actions[methodName].flow = flowArray;
    index_1.metadata.controllers[object.constructor.name] = controller;
}
function Get(path) {
    return function (object, methodName) {
        _addVerbFunctionMeta({ verb: "get", methodName, path, object });
    };
}
exports.Get = Get;
function Post(path) {
    return function (object, methodName) {
        _addVerbFunctionMeta({ verb: "post", methodName, path, object });
    };
}
exports.Post = Post;
function Put(path) {
    return function (object, methodName) {
        _addVerbFunctionMeta({ verb: "put", methodName, path, object });
    };
}
exports.Put = Put;
function Patch(path) {
    return function (object, methodName) {
        _addVerbFunctionMeta({ verb: "patch", methodName, path, object });
    };
}
exports.Patch = Patch;
function Delete(path) {
    return function (object, methodName) {
        _addVerbFunctionMeta({ verb: "delete", methodName, path, object });
    };
}
exports.Delete = Delete;
function Version(version, endpointDeprecationWarning) {
    return function (object, methodName) {
        _addVersionFunctionMeta({
            object,
            methodName,
            version,
            endpointDeprecationWarning
        });
    };
}
exports.Version = Version;
/**
 * Flow is an array of middleware you want to run prior to the controller action.
 * This is where you implement constraints like authentication, authorization and similar pre-checks.
 * @param flow
 * @constructor
 */
function Flow(flow) {
    return function (object, methodName) {
        if (typeof object === "object") {
            // action
            _addFlowFunctionMeta({ flow, methodName, object });
        }
        else if (typeof object === "function") {
            // controller
            const controller = index_1.metadata.controllers[object.name] || {};
            controller.flow = flow;
            index_1.metadata.controllers[object.name] = controller;
        }
    };
}
exports.Flow = Flow;
// argument injection decorators
function _addArgumentInjectMeta({ index, injectSource, injectOptions, methodName, object }) {
    // console.log('argument', stackConfig, injectSource, injectOptions, object, methodName);
    const controller = index_1.metadata.controllers[object.constructor.name] || {};
    controller.actions = controller.actions || {};
    controller.actions[methodName] = controller.actions[methodName] || {};
    controller.actions[methodName].arguments =
        controller.actions[methodName].arguments || {};
    controller.actions[methodName].arguments[index] = {
        injectSource,
        injectOptions
    };
    index_1.metadata.controllers[object.constructor.name] = controller;
}
function Header(injectOptions) {
    return function (object, methodName, index) {
        _addArgumentInjectMeta({
            index,
            injectSource: "header",
            injectOptions,
            methodName,
            object
        });
    };
}
exports.Header = Header;
function Body(injectOptions) {
    return function (object, methodName, index) {
        _addArgumentInjectMeta({
            index,
            injectSource: "body",
            injectOptions,
            methodName,
            object
        });
    };
}
exports.Body = Body;
function Session(injectOptions) {
    return function (object, methodName, index) {
        _addArgumentInjectMeta({
            index,
            injectSource: "session",
            injectOptions,
            methodName,
            object
        });
    };
}
exports.Session = Session;
function State(injectOptions) {
    return function (object, methodName, index) {
        _addArgumentInjectMeta({
            index,
            injectSource: "state",
            injectOptions,
            methodName,
            object
        });
    };
}
exports.State = State;
function Req(injectOptions) {
    return function (object, methodName, index) {
        _addArgumentInjectMeta({
            index,
            injectSource: "req",
            injectOptions,
            methodName,
            object
        });
    };
}
exports.Req = Req;
function Res(injectOptions) {
    return function (object, methodName, index) {
        _addArgumentInjectMeta({
            index,
            injectSource: "res",
            injectOptions,
            methodName,
            object
        });
    };
}
exports.Res = Res;
function Params(injectOptions) {
    return function (object, methodName, index) {
        _addArgumentInjectMeta({
            index,
            injectSource: "params",
            injectOptions,
            methodName,
            object
        });
    };
}
exports.Params = Params;
function Query(injectOptions) {
    return function (object, methodName, index) {
        _addArgumentInjectMeta({
            index,
            injectSource: "query",
            injectOptions,
            methodName,
            object
        });
    };
}
exports.Query = Query;
/**
 * Injects the full Koa context. Try not to do this if you don't have to.
 * @param injectOptions
 * @constructor
 */
function Ctx(injectOptions) {
    return function (object, methodName, index) {
        _addArgumentInjectMeta({
            index,
            injectSource: "ctx",
            injectOptions,
            methodName,
            object
        });
    };
}
exports.Ctx = Ctx;
//# sourceMappingURL=decorators.js.map